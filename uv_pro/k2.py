"""
Generate second-order rate constant plots.

Create and export a k2 plot quickly with custom plot titles and other settings.
The current working directory will be checked for valid fitting param .csv files to
create the second-order rate constant (k2) plot.

@author: David Hebert
"""

from dataclasses import dataclass
import os
from pathlib import Path
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.figure import Figure
from scipy.stats import linregress
import questionary
# from uv_pro.utils.filepicker import FilePicker
from uv_pro.utils.prompts import pick_files
from uv_pro.io.export import export_figure


class K2Plot:
    """
    Contains methods for creating second-order (k2) rate constant plots.

    Attributes
    ----------
    path : str
        The current working directory.
    chosen_files : list[str]
        The list of selected fitting param files.
    name : str
        The filename of the exported plot.
    linear_fits : dict
        The fitting parameters for each wavelength. A nested dict with key(s) \
        ``wavelength``. The value of ``linear_fits[wavelength]`` is also a \
        dictionary, with keys ``slope``, ``slope err``, ``intercept``, \
        ``intercept err``, ``r2``.
    kobs_data : list[pandas.Series]
        The kobs data parsed from ``chosen_files``.
    """
    def __init__(self) -> None:
        """
        Run k2 plot script.

        Parameters
        ----------
        type : str, optional
            The type of kinetics data to create the plot from. \
            Either `'exp_fit'` (kobs from exponential fit), or \
            `'init_rate'` (rate from initial rate). Default is 'exp'.
        """
        self._print_logo()
        self.path = os.getcwd()
        self.kinetics_type = 'init_rate'
        self.main()

    def main(self) -> None:
        self.chosen_files = pick_files(search_dir=r'H:\Documents\Lab Notebook\UV-Vis Spectra', ext='.csv')

        if self.chosen_files is None:
            return

        self.name = self._get_name()
        self.kobs_data = self._parse_csv()

        if self.kobs_data:
            self.linear_fits = self._linear_regression()
            self.k2_plot()

        else:
            return

    def k2_plot(self, title: str | None = None, substrate: str | None = None) -> None:
        """
        Create a second-order (k2) rate constant plot figure.

        Parameters
        ----------
        title : str or None, optional
            The figure title. Default is None.
        substrate : str or None, optional
            The substrate name (for x-axis label). Default is None.
        """
        try:
            if title is None:
                title = self._get_plot_title()
            if substrate is None:
                substrate = self._get_substrate()

        except (EOFError, KeyboardInterrupt):
            return

        fig, axs = plt.subplots(
            nrows=1,
            ncols=len(self.kobs_data),
            figsize=(16, 4),
            layout='constrained',
            sharey=False
        )

        fig.suptitle(title, fontweight='bold')

        for i, series in enumerate(self.kobs_data):
            yvals = series
            xvals = series.index

            axs[i].scatter(xvals, yvals, c='red')

            m = self.linear_fits[series.name]['slope']
            b = self.linear_fits[series.name]['intercept']
            r2 = self.linear_fits[series.name]['r2']

            axs[i].plot(xvals, xvals * m + b, linestyle=':', c='black')

            axs[i].text(
                x=0.01,
                y=0.99,
                s=f'slope: {m:.3e}\nintercept: {b:.3e}\nr$^2$ = {r2:.3f}',
                verticalalignment='top',
                horizontalalignment='left',
                transform=axs[i].transAxes,
                color='0.4',
                fontsize='8'
            )

            axs[i].set_xlim(left=0)
            axs[i].set_ylim(bottom=0)
            axs[i].set(
                xlabel=f'[{substrate}] (M)',
                ylabel='k$_{obs}$ (s$^{-1}$)',
                title=f'{series.name} (nm)'
            )

        print('Close plot window to continue...', end='\n')
        plt.show()

        self._prompt_for_changes(fig, title, substrate)

    def export(self, fig: Figure) -> str:
        return export_figure(fig, self.path, self.name)

    def _parse_csv(self) -> list[pd.Series]:
        """
        Parse .csv files for kobs data.

        Intended to be used with fitting param .csv files
        generated by uv_pro. You must input the molar concentration
        of the substrate for each file when prompted.

        Returns
        -------
        list[pandas.Series]
            The parsed kobs data where each list item
            corresponds to a different file. Wavelengths which
            have fewer than three data points are discarded.
        """
        kinetics_data = []
        col_name = 'kobs' if self.kinetics_type == 'exp_fit' else 'slope'

        for file in self.chosen_files:
            try:
                print(file)
                kinetics_data.append(pd.read_csv(file, index_col=0)[col_name].rename(fr'{file}'))

            except KeyError:
                print(f'Error: cannot retrieve {col_name} values from {file}.')
                continue

        return self._clean_data(kinetics_data)

    def _clean_data(self, kinetics_data: list[pd.Series]):
        kinetics_data = self._prompt_for_conc(kinetics_data)
        kinetics_data = self._handle_nan(kinetics_data)
        kinetics_data = self._handle_rates(kinetics_data) if self.kinetics_type == 'init_rate' else kinetics_data
        return kinetics_data

    def _prompt_for_conc(self, kinetics_data: list[pd.Series]) -> list[pd.Series] | None:
        """Prompt the user for the substrate concentration."""
        prompt = 'Enter substrate concentration (in M): '
        for series in kinetics_data:
            if conc := self._prompt_for_value(series.name, prompt, lambda x: float(eval(x))):
                series.rename(conc, inplace=True)

        return kinetics_data

    def _handle_nan(self, kinetics_data: list[pd.Series]) -> list[pd.Series]:
        """Handle NaNs in ``data`` and discard wavelengths with fewer than 3 data points."""
        df = pd.DataFrame(kinetics_data).dropna(axis='columns', thresh=3)
        df.sort_index(axis='columns', inplace=True)

        return [df[col].dropna().abs().sort_index() for col in df.columns]

    def _handle_rates(self, rates_data: list[pd.Series]) -> list[pd.Series]:
        rates = pd.DataFrame(rates_data).transpose()
        print(rates)

        for wavelength in rates.columns:
            epsilon = self._prompt_for_epsilon(wavelength)
            rates[wavelength] = rates[wavelength] / epsilon

        complex_conc = self._prompt_for_value(
            '',
            'Enter the concentration of the complex (in M): ',
            float
        )
        # complex_conc = input('\nEnter the concentration of the complex (in M): ')
        kobs = rates.divide(float(complex_conc))

        return [kobs[col] for col in kobs.columns]

    def _prompt_for_epsilon(self, wavelength: str) -> float | None:
        """Prompt the user for the molar absorptivity (epsilon)."""
        prompt = 'Enter epsilon (in M-1cm-1): '
        return self._prompt_for_value(f'{wavelength} nm', prompt, int)

    def _linear_regression(self) -> dict:
        """
        Perform linear regression fitting on ``self.kobs_data``.

        Returns
        -------
        dict
            The fitting parameters for each wavelength. A nested dict with key(s) \
            ``wavelength``. The value of ``linear_fits[wavelength]`` is also a \
            dictionary, with keys ``slope``, ``slope err``, ``intercept``, \
            ``intercept err``, ``r2``.
        """
        linear_fits = {}
        for series in self.kobs_data:
            yvals = series
            xvals = series.index

            line_fit = linregress(xvals, yvals)

            linear_fits[series.name] = {
                'slope': line_fit.slope,
                'slope err': line_fit.stderr,
                'intercept': line_fit.intercept,
                'intercept err': line_fit.intercept_stderr,
                'r2': line_fit.rvalue
            }

        return linear_fits

    def _get_name(self) -> str:
        """Create filename, attempt to find a common prefix in ``self.chosen_files``."""
        common_prefix = os.path.commonprefix(
            [os.path.splitext(file)[0] for file in self.chosen_files]
        )
        suffix = 'k2 plot'

        if common_prefix.endswith(('_', '-')):
            common_prefix = common_prefix[:-1]

        if not common_prefix.endswith(' '):
            common_prefix += ' '

        return common_prefix + suffix

    def _get_plot_title(self) -> str:
        title = input('\nEnter plot title: ')
        return title

    def _get_substrate(self) -> str:
        substrate = input('\nEnter substrate name: ')
        return substrate if substrate else 'Sub'

    def _prompt_for_value(self, title: str, prompt: str, func: callable = None):
        """Prompt the user for the substrate concentration."""
        print(f'\n{title}')

        try:
            value = input(prompt)
            return func(value) if func else value

        except (ValueError, NameError, SyntaxError):
            print('Invalid entry.')
            return

        except (EOFError, KeyboardInterrupt):
            return

    def _prompt_for_changes(self, fig: Figure, title: str, substrate: str) -> None:
        """
        Prompt the user for plot changes or export.

        Parameters
        ----------
        fig : Figure
            The current k2 plot figure.
        title : str
            The k2 plot title.
        substrate : str
            The name of the substrate (for x-axis labelling).
        """
        header = 'Make changes?'
        options = [
            {'key': '1', 'name': 'Save plot'},
            {'key': '2', 'name': 'Change title'},
            {'key': '3', 'name': 'Change x-axis label'}
        ]

        if user_choices := user_choice(header=header, options=options):
            if '1' in user_choices:
                self.exported_figure = self.export(fig)
            if '2' in user_choices:
                self.k2_plot(substrate=substrate)
            if '3' in user_choices:
                self.k2_plot(title=title)

    def _print_logo(self) -> None:
        print('\n┏┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┓')
        print('┇ uv_pro k2 Plot ┇')
        print('┗┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┛')
        print('Enter ctrl-c to quit.\n')


@dataclass
class KineticsData:
    path: Path
    concentration: float
    


if __name__ == '__main__':
    K2Plot()